const URL = require('url').URL
const chalk = require('chalk')
const path = require('path')

const { identifyDeployKey } = require('../command-helpers/auth')
const { createCompiler } = require('../command-helpers/compiler')
const { fixParameters } = require('../command-helpers/gluegun')
const { createJsonRpcClient } = require('../command-helpers/jsonrpc')
const { chooseNodeUrl } = require('../command-helpers/node')
const { withSpinner } = require('../command-helpers/spinner')
const { validateSubgraphName } = require('../command-helpers/subgraph')
const {runDeploy} = require('../lib/deploy')
const { DEFAULT_IPFS_URL } = require('../command-helpers/ipfs')
const { assertManifestApiVersion, assertGraphTsVersion } = require('../command-helpers/version')
const DataSourcesExtractor = require('../command-helpers/data-sources')
const { validateStudioNetwork } = require('../command-helpers/studio')
const Protocol = require('../protocols')

const HELP = `
${chalk.bold('graph deploy')} [options] ${chalk.bold('<subgraph-name>')} ${chalk.bold(
  '[<subgraph-manifest>]',
)}

Options:

      --product <subgraph-studio|hosted-service>
                                Selects the product to which to deploy
      --studio                  Shortcut for --product subgraph-studio
  -g, --node <node>             Graph node to which to deploy
      --deploy-key <key>        User deploy key
  -l  --version-label <label>   Version label used for the deployment
  -h, --help                    Show usage information
  -i, --ipfs <node>             Upload build results to an IPFS node (default: ${DEFAULT_IPFS_URL})
  -o, --output-dir <path>       Output directory for build results (default: build/)
      --skip-migrations         Skip subgraph migrations (default: false)
  -w, --watch                   Regenerate types when subgraph files change (default: false)
`

const processForm = async (
  toolbox,
  {
    product,
    studio,
    node,
    versionLabel,
  },
) => {
  const questions = [
    {
      type: 'select',
      name: 'product',
      message: 'Product for which to deploy',
      choices: ['subgraph-studio', 'hosted-service'],
      skip: 
        product === 'subgraph-studio' ||
        product === 'hosted-service' ||
        studio !== undefined || node !== undefined,
    },
    {
      type: 'input',
      name: 'versionLabel',
      message: 'Version Label (e.g. v0.0.1)',
      skip: versionLabel !== undefined,
    },
  ]

  try {
    const answers = await toolbox.prompt.ask(questions)
    return answers
  } catch (e) {
    return undefined
  }
}

module.exports = {
  description: 'Deploys the subgraph to a Graph node',
  run: async toolbox => {
    // Obtain tools
    let { filesystem, print, system } = toolbox

    // Parse CLI parameters
    let {
      product,
      studio,
      deployKey,
      accessToken,
      versionLabel,
      l,
      g,
      h,
      i,
      help,
      ipfs,
      node,
      o,
      outputDir,
      skipMigrations,
      w,
      watch,
    } = toolbox.parameters.options

    // Support both long and short option variants
    help = help || h
    ipfs = ipfs || i || DEFAULT_IPFS_URL
    node = node || g
    outputDir = outputDir || o
    watch = watch || w
    versionLabel = versionLabel || l

    let subgraphName, manifest
    try {
      ;[subgraphName, manifest] = fixParameters(toolbox.parameters, {
        h,
        help,
        w,
        watch,
        studio
      })
    } catch (e) {
      print.error(e.message)
      process.exitCode = 1
      return
    }

    // Show help text if requested
    if (help) {
      print.info(HELP)
      return
    }

    await runDeploy({studio,product,subgraphName, manifest, outputDir, node, ipfs, skipMigrations, accessToken, watch,versionLabel})
  },
}
