const chalk = require('chalk')
const os = require('os')
const toolbox = require('gluegun/toolbox')

const {
  getSubgraphBasename,
  validateSubgraphName,
} = require('../command-helpers/subgraph')
const { fixParameters } = require('../command-helpers/gluegun')
const { runInit, initSubgraphFromContract, initSubgraphFromExample, loadAbiFromBlockScout, loadAbiFromEtherscan, loadAbiFromFile} = require('../lib/init')
const DataSourcesExtractor = require('../command-helpers/data-sources')
const { validateStudioNetwork } = require('../command-helpers/studio')
const { withSpinner, step } = require('../command-helpers/spinner')
const { chooseNodeUrl } = require('../command-helpers/node')
const { generateScaffold, writeScaffold } = require('../command-helpers/scaffold')
const { abiEvents } = require('../scaffold/schema')
const { validateContract } = require('../validation')
const Protocol = require('../protocols')

const protocolChoices = Array.from(Protocol.availableProtocols().keys())
const availableNetworks = Protocol.availableNetworks()

const HELP = `
${chalk.bold('graph init')} [options] [subgraph-name] [directory]

${chalk.dim('Options:')}

      --protocol <${protocolChoices.join('|')}>
      --product <subgraph-studio|hosted-service>
                                 Selects the product for which to initialize
      --studio                   Shortcut for --product subgraph-studio
  -g, --node <node>              Graph node for which to initialize
      --allow-simple-name        Use a subgraph name without a prefix (default: false)
  -h, --help                     Show usage information

${chalk.dim('Choose mode with one of:')}

      --from-contract <contract> Creates a scaffold based on an existing contracts. Accepts comma separated contract addresses.
      --from-example             Creates a scaffold based on an example subgraph

${chalk.dim('Options for --from-contract:')}

      --contract-name           Name of the contract (default: Contract). Accepts comma separated contract names.
      --index-events            Index contract events as entities
      --etherscan-apikey        Etherscan API key. Default etherscan rate limit is 1 transaction per 3 sec. API key will increase ratelimt. 

${chalk.dim.underline('Ethereum:')}

      --abi <path>               Path to the contract ABI (default: download from Etherscan)
      --network <${availableNetworks.get('ethereum').join('|')}>
                                 Selects the network the contract is deployed to

${chalk.dim.underline('NEAR:')}

      --network <${availableNetworks.get('near').join('|')}>
                                 Selects the network the contract is deployed to
`

const processInitForm = async (
  toolbox,
  {abis,protocol,studio, product, node, addresses, allowSimpleName, directory, fromExample, network, subgraphName, contractNames, etherscanApikey},
) => {
  let abiFromEtherscan = undefined
  let abiFromFile = undefined
  let protocolInstance
  let ProtocolContract
  let ABI
  let addressPattern = /^(0x)?[0-9a-fA-F]{40}$/

  let questions = [
    {
      type: 'select',
      name: 'protocol',
      message: 'Protocol',
      choices: protocolChoices,
      skip: protocolChoices.includes(protocol),
      result: value => {
        protocol = protocol || value
        protocolInstance = new Protocol(protocol)
        return protocol
      },
    },
    {
      type: 'select',
      name: 'product',
      message: 'Product for which to initialize',
      choices: ['subgraph-studio', 'hosted-service'],
      skip: () =>
        protocol === 'near' ||
        product === 'subgraph-studio' ||
        product === 'hosted-service' ||
        studio !== undefined || node !== undefined,
      result: value => {
        // For now we only support NEAR subgraphs in the Hosted Service
        if (protocol === 'near') {
          // Can be overwritten because the question will be skipped (product === undefined)
          product = 'hosted-service'
          return product
        }

        if (value == 'subgraph-studio') {
          allowSimpleName = true
        }

        product = value
        return value
      },
    },
    {
      type: 'input',
      name: 'subgraphName',
      message: () => product == 'subgraph-studio' || studio ? 'Subgraph slug' : 'Subgraph name',
      initial: subgraphName,
      validate: name => {
        try {
          validateSubgraphName(name, { allowSimpleName })
          return true
        } catch (e) {
          return `${e.message}

  Examples:
  
    $ graph init ${os.userInfo().username}/${name}
    $ graph init ${name} --allow-simple-name`
        }
      },
      result: value => {
        subgraphName = value
        return value
      },
    },
    {
      type: 'input',
      name: 'directory',
      message: 'Directory to create the subgraph in',
      initial: () => directory || getSubgraphBasename(subgraphName),
      validate: value =>
        toolbox.filesystem.exists(value || directory || getSubgraphBasename(subgraphName))
          ? 'Directory already exists'
          : true,
    },
    {
      type: 'select',
      name: 'network',
      message: () => `${protocolInstance.displayName()} network`,
      choices: () =>
        availableNetworks
          .get(protocol) // Get networks related to the chosen protocol.
          .toArray(), // Needed because of gluegun. It can't even receive a JS iterable.
      skip: fromExample !== undefined,
      initial: network || 'mainnet',
      result: value => {
        network = value
        return value
      },
    },
    {
      type: 'input',
      name: 'addresses',
      message: 'Comma separated Contract addresses',
      skip: fromExample !== undefined,
      initial: addresses,
      validate: async value => {
        if (fromExample !== undefined) {
          return true
        }

        const contractList = value.split(",").map(v => v.trim());

        // Validate whether the address is valid
        for(let p=0; p<contractList.length; p++) {
          if (!addressPattern.test(contractList[p])) {
            return `Contract address "${contractList[p]}" is invalid.
       Must be 40 hexadecimal characters, with an optional '0x' prefix.`
          } 
        }
        return true
      },
      result: async value => {
        if (fromExample !== undefined) {
          return value
        }
        value = value.split(",").map(v => v.trim());
        
        // Try loading the ABI from Etherscan, if none was provided
        if (!abis && protocol !== 'near' ) {
          try {
            if (protocolInstance.hasABIs() && network === 'poa-core') {
              abiFromBlockScout = await Promise.all(value.map((c) => loadAbiFromBlockScout(network, c)))
            } else if(protocolInstance.hasABIs()) {
              abiFromEtherscan = await Promise.all(value.map((c) => loadAbiFromEtherscan(network, c, etherscanApikey)))
            }
          } catch (e) {}
        }
        return value
      },
    },
    {
      type: 'input',
      name: 'abis',
      message: 'Comma separated ABI file (path),',
      initial: abis,
      skip: () => !protocolInstance.hasABIs() || romExample !== undefined || abiFromEtherscan !== undefined,
      validate: async value => {
        if (fromExample || abiFromEtherscan || !protocolInstance.hasABIs()) {
          return true
        }
        try {
          abiFromFile = await Promise.all(value.split(",").map((abi) => loadAbiFromFile(abi.trim())));
          //abiFromFile = await loadAbiFromFile(value)
          return true
        } catch (e) {
          return e.message
        }
      },
    },
    {
      type: 'input',
      name: 'contractNames',
      message: 'Comma separated contract names',
      initial: contractNames || 'Contract',
      skip: () => fromExample !== undefined,
      validate: value => value && value.length > 0,
      result: value => {


        contractNames = value.split(",").map((v) => v.trim());
        return contractNames;
      }
    },
  ]

  try {
    let answers = await toolbox.prompt.ask(questions)
    return { ...answers, abis: abiFromEtherscan || abiFromFile ,protocolInstance}
  } catch (e) {
    return undefined
  }
}


module.exports = {
  description: 'Creates a new subgraph with basic scaffolding',
  options: {
    boolean: ['from-example'],
  },
  run: async toolbox => {
    // Obtain tools
    let { print, system } = toolbox

    // Read CLI parameters
    let {
      protocol,
      product,
      studio,
      node,
      g,
      abi,
      allowSimpleName,
      fromContract,
      contractName,
      fromExample,
      h,
      help,
      indexEvents,
      network,
      etherscanApikey
    } = toolbox.parameters.options

    let abis = abi && abi.split(",").map((a) => a.trim());
    let contractNames = contractName && contractName.split(",").map((c) => {
      const temp = c.trim();
      return temp.replace(/[^a-zA-Z0-9]/g, '');
    });
    
    let fromContracts = fromContract && fromContract.split(",").map((fc) => fc.trim())
    
    // Show help text if requested
    if (help || h) {
      print.info(HELP)
      return
    }
  
    let subgraphName, directory
    try {
      ;[subgraphName, directory] = fixParameters(toolbox.parameters, {
        fromExample,
        allowSimpleName,
        help,
        h,
        indexEvents,
        studio
      })
    } catch (e) {
      print.error(e.message)
      process.exitCode = 1
      return
    }

    fromContracts = fromContracts.map((fca, index) => {
      return {
        contractAddress: fca,
        contractAbi : abis[index],
        contractName: contractNames[index],
        templateContracts: []
      }
    })
    let initRes = await runInit({protocol,product,subgraphName, directory, network, fromContracts, etherscanApikey, indexEvents, allowSimpleName, fromExample});
    
    if(initRes !== `Process Init Form`) {
      return initRes
    }

    // Otherwise, take the user through the interactive form
    let inputs = await processInitForm(toolbox, {
      abis,
      protocol,
      product,
      studio,
      node,
      allowSimpleName,
      directory,
      addresses: fromContracts,
      fromExample,
      network,
      subgraphName,
      contractNames,
      etherscanApikey
    })

    // Exit immediately when the form is cancelled
    if (inputs === undefined) {
      process.exit(1)
    }

    print.info('———')

    // Detect Yarn and/or NPM
    let yarn = await toolbox.system.which('yarn')
    let npm = await toolbox.system.which('npm')
    if (!yarn && !npm) {
      toolbox.print.error(
        `Neither Yarn nor NPM were found on your system. Please install one of them.`,
      )
      process.exitCode = 1
      return 
    }
    
    let commands = {
      install: yarn ? 'yarn' : 'npm install',
      codegen: yarn ? 'yarn codegen' : 'npm run codegen',
      deploy: yarn ? 'yarn deploy' : 'npm run deploy',
    }

    if (fromExample) {
      await initSubgraphFromExample(
        toolbox,
        {
          subgraphName: inputs.subgraphName,
          directory: inputs.directory,
          studio: inputs.studio,
          product: inputs.product,
        },
        { commands },
      )
    } else {
      fromContracts = inputs.addresses.map((fca, index) => {
        return {
          contractAddress: fca,
          contractAbi : inputs.abis[index],
          contractName: inputs.contractNames[index],
          templateContracts: []
        }
      });
      ({ node, allowSimpleName } = chooseNodeUrl({
        product: inputs.product,
        studio,
        node,
        allowSimpleName
      }))
      await initSubgraphFromContract(
        toolbox,
        {
          protocolInstance: inputs.protocol,
          allowSimpleName,
          subgraphName: inputs.subgraphName,
          directory: inputs.directory,
          network: inputs.network,
          fromContracts,
          indexEvents,
          etherscanApikey,
          node,
          studio: inputs.studio,
          product: inputs.product,
        },
        { commands },
      )
    }
  }
}

