const path = require('path')

const util = require('../codegen/util')

const generateFieldAssignment = path =>
  `entity.${path.join('_')} = event.params.${path.join('.')}`

const generateFieldAssignments = ({ index, input }) =>
  input.type === 'tuple'
    ? util
      .unrollTuple({ value: input, index, path: [input.name || `param${index}`] })
      .map(({ path }) => generateFieldAssignment(path))
    : generateFieldAssignment([input.name || `param${index}`])

const generateMethodFieldAssignments = method => {
  let output = [`entity.blockTimestamp = call.block.timestamp`];
  output = method.inputs.reduce(
    (acc, input, index) => {
      if (input.name == 'id') {
        return acc
      }
      if (input.name == 'blockTimestamp') {
        acc.shift()
      }
      return acc.concat(generateFieldAssignments({ input, index, context: 'call', field: 'inputs' }))
    },
    output,
  );

  output = method.outputs.reduce(
    (acc, input, index) => acc.concat(generateFieldAssignments({ input, index, context: 'call', field: 'outputs' })),
    output,
  );

  return output;
}


const generateEventFieldAssignments = event => {
  let output = [`entity.blockTimestamp = event.block.timestamp`]

  output = event.inputs.reduce(
    (acc, input, index) => {
      if (input.name == 'id') {
        return acc
      }
      if (input.name == 'blockTimestamp') {
        acc.shift()
      }
      return acc.concat(generateFieldAssignments({ input, index }))
    },
    output,
  )
  if (templateContracts) {
    output = templateContracts.reduce(
      (acc, templateContract, index) => {
        if (templateContract.factoryContractEvent == event.name) {
          return acc.concat(`${templateContract.contractName}.create(event.params.${templateContract.factoryContractEventParam})`)
        }
        return acc
      },
      output,
    )
  }
  return output
}

const entityNameByMethod = (methodName, contractName) => `${contractName}${methodName}Call`;

const entityNameByEvent = (eventName, contractName) => `${contractName}${eventName}Event`;

const containsTemplateContracts = (fromContracts) => {
  let templateContract = false;
  for (let i = 0; i < fromContracts.length; i++) {
    if (fromContracts[i].templateContracts.length > 0) {
      templateContract = true;
    }
  }
  return templateContract
}

const generateEventIndexingHandlers = (events, contract, isTemplateContract, methods) => {

  const contractName = contract.contractName;
  return `
import { ${events.map(
    event => `${event._alias} as ${event._alias}Event`,
  )}} from '../generated${isTemplateContract ? `/templates` : ''}/${contractName}/${contractName}'
import { ${methods.map(
    method => `${toTitleCase(method._alias)}Call`,
  )}} from '../generated${isTemplateContract ? `/templates` : ''}/${contractName}/${contractName}'
import { ${events.map(event => `${entityNameByEvent(event._alias, contractName)} as ${entityNameByEvent(event._alias, contractName)}Schema`)} } from '../generated/schema'
import { ${methods.map(method => `${entityNameByMethod(method._alias, contractName)} as ${entityNameByMethod(method._alias, contractName)}Schema`)} } from '../generated/schema'
${(isTemplateContract || !containsTemplateContracts([contract])) ? '' : `import { ${contract.templateContracts.map(tc => tc.contractName)} } from '../generated/templates'`}

${events
      .map(
        event =>
          `
export function handle${event._alias}Event(event: ${event._alias}Event): void {
  let entity = new ${entityNameByEvent(event._alias, contractName)
          }Schema(event.transaction.hash.toHex() + '-' + event.logIndex.toString())
  entity.txHash = event.transaction.hash
  entity.fromAddress = event.transaction.from
  entity.toAddress = event.transaction.to
  entity.valueTransferred =  event.transaction.value
  entity.gasUsed = event.transaction.gasLimit
  entity.gasPrice = event.transaction.gasPrice
  ${generateEventFieldAssignments(event, templateContracts = contract.templateContracts).join('\n')}
  entity.save()
}
  `,
      )
      .join('\n')}


${methods
      .map(
        method =>
          `
export function handle${method._alias}Call(call: ${toTitleCase(method._alias)}Call): void {
  let id = call.transaction.hash.toHex()
  let entity = new ${entityNameByMethod(method._alias, contractName)}Schema(id);
  entity.txHash = call.transaction.hash
  entity.fromAddress = call.transaction.from
  entity.toAddress = call.transaction.to
  entity.valueTransferred =  call.transaction.value
  entity.gasUsed = call.transaction.gasLimit
  entity.gasPrice = call.transaction.gasPrice
  ${generateMethodFieldAssignments(method).join('\n')}
  entity.save()
}
  `,
      )
      .join('\n')}
`
}

module.exports = {
  generateFieldAssignment,
  generateFieldAssignments,
  generateEventFieldAssignments,
  generateEventIndexingHandlers,
}
